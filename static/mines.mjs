import*as tt from"./draw.mjs";import{Coord as s,newColors as b,changeColors as j,pointToCell as d,coordToValue as B,valueToCoord as C,copy as E,diagonallyAdjacent as x,colorsToSaveable as k,saveableToColors as q}from"./grid.mjs";let at=0,lt=1,nt=2;class ct{constructor(t,s,e){this.selected=new Set,this.clues=t,this.rows=t.length,this.columns=t[0].length,this.specials=s,e&&(this.state=JSON.parse(e),this.state)&&(this.state.colors=q(this.state.colors)),this.state||(this.state={input:rt(this.rows,this.columns),colors:b(this.rows,this.columns)}),this.stateUndo=[],this.stateRedo=[],this.won=!1,this.failed=!1,this.failedCoord=null}resetPuzzle(){this.selected.clear(),this.state={input:rt(this.rows,this.columns),colors:b(this.rows,this.columns)},this.stateUndo=[],this.stateRedo=[],this.won=!1,this.failed=!1,this.failedCoord=null}pushState(t){this.stateRedo=[],this.stateUndo.push(this.state),this.state=t}undo(){0!=this.stateUndo.length&&(this.stateRedo.push(this.state),this.state=this.stateUndo.pop())}redo(){0!=this.stateRedo.length&&(this.stateUndo.push(this.state),this.state=this.stateRedo.pop())}saveState(){return JSON.stringify({input:this.state.input,colors:k(this.state.colors)})}hasWon(){if(!this.won){for(var t=0;t<this.clues.length;t++)for(var s=0;s<this.clues[0].length;s++)if(0<=this.clues[t][s]^2==this.state.input[t][s])return!1;this.won=!0}return!0}draw(t,e){if(t.clearRect(0,0,t.canvas.width,t.canvas.height),tt.drawMineClues(t,this.clues,this.failedCoord),tt.drawFog(t,this.state.input),tt.drawSpecialClues(t,this.specials,this.state.input),tt.drawMineInput(t,this.state.input),e){for(var i=[],o=0;o<this.state.input.length;o++)for(var h=0;h<this.state.input[0].length;h++)if(2==this.state.input[o][h]){var a,r=new s(o,h),l=0;for(a of x(r))1==this.state.input[a.row][a.col]&&l++;l>this.clues[o][h]&&i.push(r)}tt.drawErrors(t,i,this.rows,this.columns)}tt.drawGrid(t,this.rows,this.columns),tt.drawSelected(t,this.selected),tt.drawColors(t,this.state.colors)}addToSelected(t,s){t=d(t,s);null!==t&&this.selected.add(B(t))}clearSelected(){this.selected.clear()}addColor(t){this.pushState({input:this.state.input,colors:j(this.state.colors,t,this.selected)})}allowsLines(){return!1}controls(){return[{text:"Reveal",class:"mine-control",keys:["KeyZ","Space"],method:function(t){t.reveal()}},{text:"Flag",class:"mine-control",keys:["KeyX"],method:function(t){t.flag()}}]}instructions(){return`
		<p>
		Select the "Controls" tab.  Select cells by clicking and draging across the grid.  Click "Reveal" or press "Z" or "Space" to open a cell.  Click "Flag" or press "X" to place a hint where mines are located.
		</p>
		<p>
		Holding "Shift" or "Ctrl" while clicking on the grid will add to the selected cells.
		</p>
		`}reveal(){if(!this.failed&&!this.won){var t,s=[];for(t of this.selected){var e=C(t);0==this.state.input[e.row][e.col]&&s.push(e)}if(0!=s.length){for(var i=E(this.state.input);0<s.length;){if(i[(e=s.pop()).row][e.col]=2,this.clues[e.row][e.col]<0){this.failed=!0,this.failedCoord=e;break}if(0==this.clues[e.row][e.col])for(var o of x(e))s.push(o)}this.pushState({input:i,colors:this.state.colors})}}}flag(){if(!this.failed&&!this.won){var t=[],s=[];for(o of this.selected){var e=C(o);2!=this.state.input[e.row][e.col]&&t.push(e),0==this.state.input[e.row][e.col]&&s.push(e)}if(0<s.length){var i=E(this.state.input);for(o of s)i[o.row][o.col]=1;this.pushState({input:i,colors:this.state.colors})}else if(0<t.length){var o,i=E(this.state.input);for(o of t)i[o.row][o.col]=0;this.pushState({input:i,colors:this.state.colors})}}}}function rt(t,s){for(var e=[],i=0;i<t;i++){for(var o=[],h=0;h<s;h++)o.push(0);e.push(o)}return e}export{at as HIDDEN,lt as FLAGGED,nt as REVEALED,ct as MineHandler};